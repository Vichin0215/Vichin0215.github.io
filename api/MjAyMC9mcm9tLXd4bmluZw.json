{"title":"go语言搭建pipeline","date":"2020-04-02T03:27:33.000Z","date_formatted":{"ll":"2020年4月2日","L":"2020/04/02","MM-DD":"04-02"},"link":"2020/from-wxning","tags":["Go","pipeline"],"categories":["go项目"],"updated":"2020-06-05T08:16:48.060Z","content":"<h2 id=\"pipeline\">pipeline<a href=\"#pipeline\" title=\"pipeline\"></a></h2><p>有个数据源，把这个数据源送到一个节点，这个节点处理完再送到下一个节点，这样一级一级送下去，最后又一个Sink，Sink节点只进不出。</p>\n<p>节点和节点之间怎么通信呢？</p>\n<p>传统语言是通过方法调用实现的。</p>\n<p>Go语言是通过channel通信的</p>\n<h2 id=\"归并排序\">归并排序<a href=\"#归并排序\" title=\"归并排序\"></a></h2><p>数据分为左右两半，分别归并排序，再把两个有序数据合并</p>\n<h2 id=\"外部排序pipeline\">外部排序pipeline<a href=\"#外部排序pipeline\" title=\"外部排序pipeline\"></a></h2><p>首先有个原始数据，然后分块得读取这个原始数据，保证内存能够放得下，每一块各自进行内部排序，排好序后两两进行归并，每个归并节点放的都是排好序的大数据，然后再两两归并，最后写入文件中。</p>\n<p><img src=\"C:/Users/ASUS/Documents/WeChat%20Files/lwq2428779008/FileStorage/File/2020-04/images/pipeline-4.png\" class=\"φcy\" alt=\"pipeline-1\"></p>\n<h2 id=\"实现\">实现<a href=\"#实现\" title=\"实现\"></a></h2><h2 id=\"基础节点\">基础节点<a href=\"#基础节点\" title=\"基础节点\"></a></h2><p>首先我们有一个数据源，它返回的是一个channel</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ArraySource</span><span class=\"params\">(a ...<span class=\"keyword\">int</span>)</span> &lt;-<span class=\"title\">chan</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\tout := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> a &#123;</span><br><span class=\"line\">\t\t\tout &lt;- v</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">close</span>(out)</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> out</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>然后对这个数据源进行内部排序</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">InMenSort</span><span class=\"params\">(in &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span> &lt;-<span class=\"title\">chan</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\tout := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Read into memory</span></span><br><span class=\"line\">\t\ta := []<span class=\"keyword\">int</span>&#123;&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> v := <span class=\"keyword\">range</span> in &#123;</span><br><span class=\"line\">\t\t\ta = <span class=\"built_in\">append</span>(a, v)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Sort</span></span><br><span class=\"line\">\t\tsort.Ints(a)</span><br><span class=\"line\">\t\t<span class=\"comment\">//Output</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> a &#123;</span><br><span class=\"line\">\t\t\tout &lt;- v</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">close</span>(out)</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> out</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>主函数直接拼接起来</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"pipeline/pipeline\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tp := pipeline.InMenSort(pipeline.ArraySource(<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">4</span>))</span><br><span class=\"line\">\t<span class=\"comment\">// 用range发送方一定要close</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> v := <span class=\"keyword\">range</span> p &#123;</span><br><span class=\"line\">\t\tfmt.Println(v)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就实现了一个基础的内部排序了！</p>\n<h2 id=\"归并节点\">归并节点<a href=\"#归并节点\" title=\"归并节点\"></a></h2><p>讲两个内部排序归并</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Merge</span><span class=\"params\">(in1, in2 &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span> &lt;-<span class=\"title\">chan</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    out := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">      v1, ok1 := &lt;-in1</span><br><span class=\"line\">      v2, ok2 := &lt;-in2</span><br><span class=\"line\">      <span class=\"keyword\">for</span> ok1 || ok2 &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> !ok2 || (ok1 &amp;&amp; v1 &lt;= v2) &#123;</span><br><span class=\"line\">          out &lt;- v1</span><br><span class=\"line\">          v1, ok1 = &lt;-in1</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          out &lt;- v2</span><br><span class=\"line\">          v2, ok2 = &lt;-in2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">close</span>(out)</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>主函数merge两个内部排序节点</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"pipeline/pipeline\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tp := pipeline.Merge(pipeline.InMenSort(pipeline.ArraySource(<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">4</span>)),pipeline.InMenSort(pipeline.ArraySource(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">9</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>)))</span><br><span class=\"line\">\t<span class=\"comment\">// 用range发送方一定要close</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> v := <span class=\"keyword\">range</span> p &#123;</span><br><span class=\"line\">\t\tfmt.Println(v)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>现在我们已经实现了从array读取数据源，然后用两个内部排序节点排序，最后再通过merge将两个节点归并。</p>\n<p>我们的数据源是从array读取，这点不好，让我们来从文件中读取吧！</p>\n<h2 id=\"文件读写\">文件读写<a href=\"#文件读写\" title=\"文件读写\"></a></h2><p>在外部排序中数据源要是一个文件</p>\n<p>读文件，这里统一用大端BigEndian读取数据</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ReaderSource</span><span class=\"params\">(reader io.Reader)</span> &lt;-<span class=\"title\">chan</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\tout := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\tbuffer := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"number\">8</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t\tn, err := reader.Read(buffer)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> n &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 把[]byte转化为int</span></span><br><span class=\"line\">\t\t\t\tv := <span class=\"keyword\">int</span>(binary.BigEndian.Uint64(buffer))</span><br><span class=\"line\">\t\t\t\tout &lt;- v</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">close</span>(out)</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> out</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>写文件</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">WriterSink</span><span class=\"params\">(writer io.Writer, in &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> v := <span class=\"keyword\">range</span> in &#123;</span><br><span class=\"line\">\t\tbuffer := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"number\">8</span>)</span><br><span class=\"line\">\t\tbinary.BigEndian.PutUint64(buffer, <span class=\"keyword\">uint64</span>(v))</span><br><span class=\"line\">\t\twriter.Write(buffer)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>当然数据源应该是自动产生的，我们再实现一个随机产生数据源的方法</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">RandomSource</span><span class=\"params\">(count <span class=\"keyword\">int</span>)</span> &lt;-<span class=\"title\">chan</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\tout := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; count; i++ &#123;</span><br><span class=\"line\">\t\t\tout &lt;- rand.Int()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> out</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>我们的main函数如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> filename = <span class=\"string\">\"large.in\"</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> n = <span class=\"number\">100000000</span></span><br><span class=\"line\">\tfile, err := os.Create(filename)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> file.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">\tp := pipeline.RandomSource(n)</span><br><span class=\"line\">\tpipeline.WriterSink(file, p)</span><br><span class=\"line\">\tfile, err = os.Open(filename)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> file.Close()</span><br><span class=\"line\">\tp = pipeline.ReaderSource(file)</span><br><span class=\"line\">\tcount := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> v := <span class=\"keyword\">range</span> p &#123;</span><br><span class=\"line\">\t\tfmt.Println(v)</span><br><span class=\"line\">\t\tcount++</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> count &gt;= <span class=\"number\">100</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>这就实现了自动生成随机数，并写入文件</p>\n<p>但是上面这段代码是大数据，一共产生100兆个数，速度很慢，为什么这么慢呢？</p>\n<p>因为Reader和Writer没有buffer</p>\n<p>我们再给Reader和Writer加个buffer</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> filename = <span class=\"string\">\"large.in\"</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> n = <span class=\"number\">100000000</span></span><br><span class=\"line\">    file, err := os.Create(filename)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">      \t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> file.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">    p := pipeline.RandomSource(n)</span><br><span class=\"line\"></span><br><span class=\"line\">    writer := bufio.NewWriter(file)</span><br><span class=\"line\">    pipeline.WriterSink(writer, p)</span><br><span class=\"line\">    writer.Flush()</span><br><span class=\"line\"></span><br><span class=\"line\">    file, err = os.Open(filename)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">      \t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> file.Close()</span><br><span class=\"line\">    reader := bufio.NewReader(file)</span><br><span class=\"line\">    p = pipeline.ReaderSource(reader)</span><br><span class=\"line\">    count := <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> v := <span class=\"keyword\">range</span> p &#123;</span><br><span class=\"line\">      fmt.Println(v)</span><br><span class=\"line\">      count++</span><br><span class=\"line\">      <span class=\"keyword\">if</span> count &gt;= <span class=\"number\">100</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>buffer的writer要记得flush，不然得到的数据就不是800兆了。</p>\n<p>现在我们实现了更多的节点，有ReaderSource和WriterSink，我们又用随机数演示测试数据的生成，都用bufio包装了，所以速度很快</p>\n<h2 id=\"完整外部排序\">完整外部排序<a href=\"#完整外部排序\" title=\"完整外部排序\"></a></h2><p>现在我们这个外部排序pipeline还有一些没有完成，一个是读取文件要分块读取，还有两两归并再归并还没有实现</p>\n<p>现在我们来实现这些功能吧！</p>\n<p>首先我们来实现多路的两两归并</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">MergeN</span><span class=\"params\">(inputs ...&lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span> &lt;-<span class=\"title\">chan</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(inputs) == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> inputs[<span class=\"number\">0</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    m := <span class=\"built_in\">len</span>(inputs) / <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"comment\">// merge inputs[0..m) and inputs[m..end)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Merge(MergeN(inputs[:m]...), MergeN(inputs[m:]...))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>看起来很简单啊，只是用递归去实现了一下</p>\n<p>然后我们reader读文件要分块</p>\n<p>那我们来改造一下ReaderSource</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ReaderSource</span><span class=\"params\">(reader io.Reader, chunkSize <span class=\"keyword\">int</span>)</span> &lt;-<span class=\"title\">chan</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\tout := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">      buffer := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"number\">8</span>)</span><br><span class=\"line\">      bytesRead := <span class=\"number\">0</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">          n, err := reader.Read(buffer)</span><br><span class=\"line\">          bytesRead += n</span><br><span class=\"line\">          <span class=\"keyword\">if</span> n &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">              <span class=\"comment\">// 把[]byte转化为int</span></span><br><span class=\"line\">              v := <span class=\"keyword\">int</span>(binary.BigEndian.Uint64(buffer))</span><br><span class=\"line\">              out &lt;- v</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> || (chunkSize != <span class=\"number\">-1</span> &amp;&amp; bytesRead &gt;= chunkSize) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">break</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">close</span>(out)</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> out</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>这里我们设置chunkSize为-1表示全部读，否则就是不能超过chunkSize读取</p>\n<p>很简单吧！现在我们开始实现外部排序吧！</p>\n<p>首先我们来创建一个pipeline</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">createPipeline</span><span class=\"params\">(filename <span class=\"keyword\">string</span>, fileSize, chunkCount <span class=\"keyword\">int</span>)</span> &lt;-<span class=\"title\">chan</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    chunkSize := fileSize / chunkCount</span><br><span class=\"line\"></span><br><span class=\"line\">    sortResults := []&lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; chunkCount; i++ &#123;</span><br><span class=\"line\">        file, err := os.Open(filename)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">          \t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// file要从这一块开始读，所以file要移动一下</span></span><br><span class=\"line\">        file.Seek(<span class=\"keyword\">int64</span>(chunkSize * i), <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        source := pipeline.ReaderSource(bufio.NewReader(file), chunkSize)</span><br><span class=\"line\">        sortResults= <span class=\"built_in\">append</span>(sortResults, pipeline.InMenSort(source))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> pipeline.MergeN(sortResults...)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>这里我们分块去读，每次读file都移动一下，然后排好序，把结果merge起来。</p>\n<p>接下来我们把排好序的数据写入文件</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">writeToFile</span><span class=\"params\">(p &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, filename <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">    file, err := os.Create(filename)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">      \t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> file.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">    writer := bufio.NewWriter(file)</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> writer.Flush()</span><br><span class=\"line\"></span><br><span class=\"line\">    pipeline.WriterSink(writer, p)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>然后再打印出来</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printFile</span><span class=\"params\">(filename <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">    file, err := os.Open(filename)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">      \t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> file.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">    p := pipeline.ReaderSource(file, <span class=\"number\">-1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> v := <span class=\"keyword\">range</span> p &#123;</span><br><span class=\"line\">      \tfmt.Println(v)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>最后主函数这样写</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    p := createPipeline(<span class=\"string\">\"small.in\"</span>, <span class=\"number\">512</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">    writeToFile(p, <span class=\"string\">\"small.out\"</span>)</span><br><span class=\"line\">    printFile(<span class=\"string\">\"small.out\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>但是程序还是很慢，排序需要跑将近30秒，我们看慢在哪里，channel是无缓存的，这样就会阻塞等待，所以我们给channel加个1024的缓存。</p>\n<p>虽然排序是并行的排的，但是merge是O(n)的，每个数都要过一下。所以时间比非并行的要慢。</p>\n<p>我们来看一下输出结果：</p>\n<p><img src=\"C:/Users/ASUS/Documents/WeChat%20Files/lwq2428779008/FileStorage/File/2020-04/images/pipeline-6.png\" class=\"φcy\" alt=\"pipeline-6\"></p>\n<p>很好！</p>\n<h2 id=\"网络版外部排序\">网络版外部排序<a href=\"#网络版外部排序\" title=\"网络版外部排序\"></a></h2><p>InMemSort和WriterSink之间通过网络连接，ReaderSource和Merge之间通过网络连接</p>\n<p>首先我们把服务器搭起来</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NetWorkSink</span><span class=\"params\">(addr <span class=\"keyword\">string</span>, in &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">    listener, err := net.Listen(<span class=\"string\">\"tcp\"</span>, addr)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">      \t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">defer</span> listener.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">      conn, err := listener.Accept()</span><br><span class=\"line\">      <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        \t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">defer</span> conn.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">      writer := bufio.NewWriter(conn)</span><br><span class=\"line\">      <span class=\"keyword\">defer</span> writer.Flush()</span><br><span class=\"line\"></span><br><span class=\"line\">      WriterSink(writer, in)</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>然后封装一下客户端</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NetworkSource</span><span class=\"params\">(addr <span class=\"keyword\">string</span>)</span> &lt;-<span class=\"title\">chan</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    out := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        conn, err := net.Dial(<span class=\"string\">\"tcp\"</span>, addr)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">          \t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        r := ReaderSource(bufio.NewReader(conn), <span class=\"number\">-1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> v := <span class=\"keyword\">range</span> r &#123;</span><br><span class=\"line\">          \tout &lt;- v</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">close</span>(out)</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>然后我们再把createPipeline封装成network版</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">createNetworkPipeline</span><span class=\"params\">(filename <span class=\"keyword\">string</span>, fileSize, chunkCount <span class=\"keyword\">int</span>)</span> &lt;-<span class=\"title\">chan</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    chunkSize := fileSize / chunkCount</span><br><span class=\"line\">    pipeline.Init()</span><br><span class=\"line\"></span><br><span class=\"line\">    sortAddr := []<span class=\"keyword\">string</span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; chunkCount; i++ &#123;</span><br><span class=\"line\">        file, err := os.Open(filename)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">          \t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// file要从这一块开始读，所以file要移动一下</span></span><br><span class=\"line\">      file.Seek(<span class=\"keyword\">int64</span>(chunkSize * i), <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">      source := pipeline.ReaderSource(bufio.NewReader(file), chunkSize)</span><br><span class=\"line\"></span><br><span class=\"line\">      addr := <span class=\"string\">\":\"</span> + strconv.Itoa(<span class=\"number\">7000</span> + i)</span><br><span class=\"line\">      pipeline.NetWorkSink(addr, pipeline.InMenSort(source))</span><br><span class=\"line\">      sortAddr = <span class=\"built_in\">append</span>(sortAddr, addr)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    sortResults := []&lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, addr := <span class=\"keyword\">range</span> sortAddr &#123;</span><br><span class=\"line\">      \tsortResults = <span class=\"built_in\">append</span>(sortResults, pipeline.NetworkSource(addr))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pipeline.MergeN(sortResults...)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以部署到服务器上了</p>\n<p>好了，用go语言搭建并行处理管道已经完成了！</p>\n","prev":{"title":"Hello Blog","link":"2020/hello-blog"},"plink":"https://vichin0215.github.io/2020/from-wxning/","toc":[{"id":"pipeline","title":"pipeline","index":"1"},{"id":"归并排序","title":"归并排序","index":"2"},{"id":"外部排序pipeline","title":"外部排序pipeline","index":"3"},{"id":"实现","title":"实现","index":"4"},{"id":"基础节点","title":"基础节点","index":"5"},{"id":"归并节点","title":"归并节点","index":"6"},{"id":"文件读写","title":"文件读写","index":"7"},{"id":"完整外部排序","title":"完整外部排序","index":"8"},{"id":"网络版外部排序","title":"网络版外部排序","index":"9"}],"reward":true,"copyright":{"author":"Vichin","updated":"2020年6月5日","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}