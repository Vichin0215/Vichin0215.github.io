[{"title":"Poster-2","date":"2020-06-22T14:13:21.000Z","date_formatted":{"ll":"2020年6月22日","L":"2020/06/22","MM-DD":"06-22"},"updated":"2020-06-22T14:30:25.116Z","content":"未来主义海报设计练习 2：碎片化图形的绘制\n（Illustrator绘制抽象化碎片图形+photoshop优化）\n作品展示：\n制作步骤：在illustrator中绘制抽象化图形\n新建一个A4画布\n画笔工具，画笔库菜单，艺术效果_水彩\n选择水彩-厚重，调整像素在画布上随意画出一些痕迹，叠加水彩描边\nCtrl+A,对象菜单，扩展外观\n直接选择工具，选中全部，选择渐变，渐变滑块两边选择红色和蓝色\nCtrl+A选中全部，Ctrl+C复制\n在Photoshop中的颜色调整和优化\n新建画布，Ctrl+V粘贴为智能对象（只能对象的好处在于可在illustrator和ps中来回切换：双击原图形的图层右下角按确定后可以直接回到illustrator编辑，保存后会直接同步到Photoshop）\n调整好图形的大小后按回车键\n右击图形的图层，选择栅格化图层，这样就不能再回到illustrator做调整了\n图像菜单，调整，色相/饱和度，调整一下色相及饱和度等\n在背景和图形之间新建一个图层，选择椭圆工具，按住shift键绘制一个正圆，颜色为白色\n选中图形图层，滤镜菜单，杂色，添加杂色，调整数值；图像菜单，调整，亮度/对比度，调整数值\nps添加字母元素(建立版式，创建文字的遮罩效果)\n在图形之上新建一个图层\n选中文字工具，大小为40pt,选择喜欢的字体（这里用的是Tw Cen MT），颜色为深紫色，输入Tutorial，按Ctrl+T启动自由变换，同时按住alt+shift键可以等比例放大\n（栅格化tutorial文字图层？）选择多边形套索工具，框选要隐藏的部分后删除（套索工具选择的区域最后是封闭的图形）\n添加装饰元素（线条等）\n在illustrator用画笔创作像碎纸片一样的素材，Ctrl+A选中，对象菜单，扩展外观，Ctrl+C复制\n在ps中Ctrl+V粘贴为形状图层，Ctrl+T选中全部调整大小，双击图层更换适合的颜色，将形状图层放在图形上面字体下面\n可以如2多添加不同形状的元素\n添加字体（Ctrl+A选中所有字母快捷键alt+→:扩大字间距；alt+↓:扩大行间距）,字体图层放在最上面，使字体分散在各个位置\n新建一个图层，用很细的画笔随意画一些小线条\n新建一个图层，放大画笔，选择带羽化的笔刷样式，点击一下产生一个亮点，将图层中的正常模式改为叠加，再复制一个放到别的地方，调整大小（选中两个图层可以用Ctrl+G合并成一个组）\n保存完成\n","thumbnail":"2020/Poster-2/poster2.jpg","color":"#111","plink":"https://vichin0215.github.io/2020/Poster-2/"},{"title":"数据结构绪论","date":"2020-06-22T07:50:03.000Z","date_formatted":{"ll":"2020年6月22日","L":"2020/06/22","MM-DD":"06-22"},"updated":"2020-06-22T08:56:46.935Z","content":"一.时间复杂度logn —&gt; n —&gt; nlog n —&gt; n² —&gt; n³ —&gt; 2³\n二.分而治之最大子列和问题\n题目：给定N个整数的序列{A₁,A₂,…,An},求最大子列和\n1.算出全部子列和，找最大值\n2.简化算法1\n3.分而治之\n*4.在线处理*\n","plink":"https://vichin0215.github.io/2020/data-structrue-1/"},{"title":"未来主义海报练习pic-1","date":"2020-06-21T10:00:06.000Z","date_formatted":{"ll":"2020年6月21日","L":"2020/06/21","MM-DD":"06-21"},"updated":"2020-06-22T14:19:04.324Z","content":"未来主义海报设计练习 1 ：渐变图形的绘制\n（Illustrator绘制渐变效果+photoshop优化）\n作品展示：制作步骤： illustrator(绘制渐变效果)\n创建文档，确保高级设置中的颜色模式为RGB\n矩形工具，绘制一个矩形\n描边，设置为无；填充用暗紫色，可双击填色调整颜色深浅\n网格工具，在矩形框内随意点击分割出很多网格\n直接选择工具，点击任意一个交点，双击填色选择颜色填充（快捷键A转换直接选择工具，按住shift键可多选不同的点），最后不要忘记填充矩形边框的点\n按快捷键A选定多个点或一个点，可任意拖拽移动颜色（建议不要移动太多不然看着会像固体）\n选择工具，双击矩形图案，复制粘贴到ps\nps(优化定稿)\n创建新文件，确保颜色模式为RGB\n粘贴时，粘贴为像素（不占用太多运行数据）\n调整为适合画布的大小\n椭圆工具，按住shift绘制一个正圆\n将渐变图层移到圆形上方\n右击渐变图层，创建剪贴蒙版\n可以放大移动选取颜色好看的区域填充圆形\n在对图形进行变形之前，为了确保万一，先复制一份：选中椭圆图层，按住shift键同时选定渐变图层，按Ctrl+G,右击这组选择复制组，先隐藏这组，仅预览组1；右击组1，选择合并组合，将它整合变成图层\nCtrl+T,选中矩形，右击，选择变形，可拖动任何地方使图案变形。弄好后随意点击右上角的√确定\n添加噪点使之变得更平滑：滤镜菜单下选择杂色，添加杂色，调整百分比\n提亮颜色：图像菜单下选择调整，色相/饱和度，调整饱和度等\n添加一个光点：在最上方新建一个图层，进行以下操作：选择画笔工具，快捷键 】放大画笔；选择吸管工具，在渐变图上选择一个颜色；选择画笔工具，在需要光点的地方点击一下，可以用移动工具移动其位置，然后可以为其添加噪点：滤镜–&gt;杂色–&gt;添加杂色–&gt;调整百分比\n添加一些线条元素：新建一个图层（快捷键：Ctrl+Shift+N）；选择画笔工具（快捷键B）,缩小画笔大小至小细线；选择吸管工具（快捷键I）,点击图案吸取一个颜色；快键键B返回画笔工具，随意画一些小线条。（可以再新疆图层，选择别的颜色，再返回画笔工具画其他颜色的线条）\n保存完成\n","thumbnail":"2020/Poster-1/poster1.jpg","color":"#111","plink":"https://vichin0215.github.io/2020/Poster-1/"},{"title":"记308宿舍第一次聚餐","date":"2020-06-06T01:35:26.000Z","date_formatted":{"ll":"2020年6月6日","L":"2020/06/06","MM-DD":"06-06"},"updated":"2020-06-06T12:47:43.286Z","content":"  几周前我和一个室友都转专业成功了，这个学期末或下个学期一开学就要搬到另一个校区的宿舍了。因为疫情这个学期都不能解封出去了，所以昨天我们就点了烧烤、披萨、奶茶外卖在宿舍简单作为第一次也可能是最后一次聚餐。\n谈起大学室友，我想我是幸运的。从入学到现在换过两个宿舍，庆幸的是遇到的室友都是很友好的女孩子，互相之间也没有什么矛盾，没有发生像网上所说那种女生间的勾心斗角。即使刚开始由于生活习性或个人性格方面我会有点不能接受而自己偷偷吐槽，但越相处越会发现更多她温暖和细心的地方，就慢慢淡然了。\n这里要提起一个室友小T，我们大一担任各自班的副班长，因为工作上的事而相识，但一直不熟，后来因为我们都要转计算机专业才慢慢熟悉起来，大二开学换校区也住到了同一个宿舍直到现在。但刚开始住一起的时候我是有点不喜欢她的，不知道是因为我们都是要转同一个专业的，有竞争关系还是单纯因为好奇心，她总会关心我的举动。比如我穿鞋换衣服准备出去她就会问我去干嘛，是去图书馆吗；因为我的书桌在入门第一位，她无论是从外面回来还是过来这边接水，经过我座位的时候都会看看我在干嘛，如果我在看电脑也会凑过来看是什么内容，问我在学什么，是在编程吗；而且这一点和之前那个宿舍的一个室友也好像，她也总喜欢问我去干嘛，那时候我每天都是宿舍最早起床的，她就会问我去干嘛，去自习室吗……我是特别不喜欢这种感觉的，我也有自己的空间啊，连自己在做什么都要告知别人的感觉让我觉得很烦人。\n说回小T，这样子不冷不热过了一段时间之后，慢慢因为转专业的事我们开始经常聊天，她有朋友是大一成功转到计算机专业的，而我认识几个计算机专业的学长学姐和同学，我们有什么消息也会立刻告诉对方。这个学期准备转专业的事也挺多的，加之因为疫情封校，每次吃饭都会一起去食堂。慢慢的她也不那么关注我在干嘛了，即使有时候问我也没那么反感了，就说在看什么什么。而慢慢也觉得她其实也是个挺好的人，如果我有什么困难了她会特别热心地帮忙；别人和她说话的时候她会停下手里的事认真听，每次都会给予对方回应，我好像还没见过她不开心的时候，她也不会无端端给别人不好的态度和脸色。我之所以有这个感受是因为在之前的宿舍有两个室友有时候我都不敢和她们说话，有时候是因为起床气，这个也可以理解吧，但还有一次我记得是我们一起出去吃饭，有个室友不知道是不开心还是因为不喜欢这个店的菜，我们问她想吃什么，她就很不耐烦的翻了翻菜单，然后说句“随便吧”就自己玩手机了，搞得很尴尬；还有几次是可能正好遇上她心情不好吧，和她说话她也不应，这种真的让人感受挺不好的，但也只是很少数的情况了。有一次我因为某些事在阳台打电话情绪崩溃了一直在大哭，过了一会小T拿了一包纸巾出来给我，轻轻拍了两下我肩膀就回去了。那时候哭得挺厉害的，她的举动将我从困境中解救出来，一言不发却默默给了我安慰。\n我们宿舍是大二才住在一起的，五个人来自三个班，互相间刚开始基本不认识，住了一段时间才开始熟悉，但直到快一年了才大家一起聚在一起吃东西聊天，才有宿舍第一张合照，之前也没人提过要一起出去吃饭，可能是大家都觉得不够熟悉吧。聊天刚开始也只是吐槽点的外卖这个好吃那个不好吃，后来慢慢的就开始聊起自己小时候的事，聊家里的事，我们的家庭环境各不相同，但是从来没有感受到谁有优越感或谁对此自卑。其实我觉得这个宿舍的氛围我真的挺喜欢的，有时候会很安静，有时候会大家一起聊天说笑，每个人性格都很好，都是很善良友好的女孩子。如果说我的大学有什么可怀念的，除了和王先生的相识，就是遇到了这么一群好室友吧。\n王先生对于我要换宿舍似乎有着比我还多的不舍，也许他是担心我去到新的宿舍室友不像现在的那么好了。但其实我觉得还好，一是我不怎么担心这个问题，二是我觉得剩下的时间室友关系好像也不是那么重要了。曾经我也是特别不喜欢离别，我一直觉得自己是一个重感情的人，即使只在一起待过几天要分别了还是会很难过，现在似乎好一点点了。我想，人的一生注定要遇到很多人，而大部分都只会成为过客停留在回忆里，我们走走停停，不断拥有又不断失去，正是这样才懂得珍惜。\n我对大学的初认识应该是在小学看的小说里，清爽的夏日傍晚，女主角穿着纯洁的白色连衣裙漫步在校园林荫小道上，而男主在旁边篮球场上挥汗淋漓的展示帅气球技，这时，篮球一不小心砸到了女主，往后便开始了男主和女主相爱相杀的故事……但上大学之后，令我万万没想到的现实是，我们居然还要上晚自习！所以并没有时间慢慢散步，一吃完饭就差不多要准备去晚自习写作业了哈哈哈🤣\n转眼我的大学已经过去一大半了，如果要问我最大的收获是什么，第一必定是自己迷茫寻找的方向有了答案，并在这期间遇到了我想要共度一生的人。再者，我庆幸自己至此遇到的都是充满善意的人，我想，从某个方面来讲，我是幸运的。\n往后的室友如果不是那么友好也没有很大关系了吧，我想这剩下的一年多我要专心于沉淀自己，努力补回落下的知识。星光不负赶路人，我还来得及，要对有勇气重头来过的自己有信心！最后，真心祝愿这几个天真温暖的女孩子都能有光明幸福的未来。\n","thumbnail":"2020/Dormitory-dinner/pink_sky.jpg","color":"#111","plink":"https://vichin0215.github.io/2020/Dormitory-dinner/"},{"title":"又是一年毕业时","date":"2020-06-04T13:25:44.000Z","date_formatted":{"ll":"2020年6月4日","L":"2020/06/04","MM-DD":"06-04"},"updated":"2020-06-06T05:49:36.017Z","content":"  今天早上七点多就听到了对面宿舍楼传来的喧吵声，走出阳台一看发现很多毕业班的学姐穿上了学士服，正忙着梳妆。噢，原来今天是他们拍毕业照的日子。\n  去吃早餐的路上看到操场上聚满了穿戴着学士服的毕业生，直到吃午饭的时候才散场。看着走在我面前的学姐，我心想，要是在平时我绝对分辨不出他们是大二、大三还是大四，但是此时看到穿着学士服手捧鲜花的他们，竟也隐约觉得他们脸上多了几分不同于我们的成熟。\n\n这是我进入大学以来的第二个毕业季了，大一似乎对于毕业并没有太大的感受，可能是觉得自己还年轻还有很多时间，因为好奇还悠悠然去参观了招聘会，其间看到一个穿着白衬衫高跟鞋的学姐在和面试官神采飞扬地谈话，感到敬佩的同时竟然也不由心生了一丝紧张。一年时间过得比我想象中的快了好多，今年毕业季的感受也更复杂了，相比去年更多的是着急和慌乱。真正意义上来讲我的大学才刚刚开始，我的学习收获还几乎是0，而时间却只剩两年了，甚至更少。我在想，到了属于我的毕业季的时候我会是怎样的呢，我找到工作了吗？我是不是也在为了毕业论文煎熬地度过许多个日日夜夜？我有目标了吗，我离开学校后会到哪里？我们拍毕业照那天天气会好吗，会不会也像今天一样下雨呢？我们宿舍关系怎么样，会不会有好朋友和我一起拍毕业照？这么想想好像对毕业又多了几分期待哈哈，在大一我就想大学快点结束吧，好想可以马上毕业，可现在我多希望时间能慢一点，让我有更多的时间去努力让自己变得更好。\n  看到有的学姐捧着鲜花，我室友说，肯定是男朋友送的，我笑说，说不定是自己买来给拍照用的。想起去年王先生和我说，等我毕业的时候他会来的。现在这个时候他还在忙，两年后的今天他又会有时间吗？我多想毕业那天他也在场啊，可以拥抱着和我说“毕业快乐”。这会实现吗？\n","thumbnail":"2020/graduation/playground.jpg","color":"#111","plink":"https://vichin0215.github.io/2020/graduation/"},{"title":"Hello Blog","date":"2020-05-28T13:40:00.000Z","date_formatted":{"ll":"2020年5月28日","L":"2020/05/28","MM-DD":"05-28"},"updated":"2020-06-06T05:58:31.309Z","content":"花费了很长时间终于基本建好了这个还不太完美的博客。\n  由于自己能力有限，还有很多想要的功能不懂怎么实现。熊宁总说，博客的内容才是最重要的，但我就是那种一做就一定要做得很完美的性格，不然心里总觉得不舒畅不舒服（包括现在也有点哈哈哈）。想想自己确实还什么也不懂，有的方法别人已经写出来了可是我还是不理解、做不对，或许现在确实不必太过纠结。\n  今天在群里问了一个问题，因为我的图片上传不了，我不知道是什么原因。后来群里有两个人告诉我问题是什么什么，可我居然听不懂，所以又问了一遍具体应该怎么做。这时有位群友告诉了我做法，还建议我使用图床会更好，后来问题解决了。在这其间有个人说了一句：“这基础也太差了”，虽然他刚发就马上撤了回去，但我还是看到了。那时候心里其实还挺不舒服的吧，刚想要解释一下，后来又觉得好像也没有必要了。我现在的确还什么也不懂啊，我问的东西可能在他们眼里是很低级、很弱智的问题吧，但是我自己却找不出原因也理解不了。过了一会，当时告诉我做法的群友私聊了问我不是计算机专业的吧？突然好像心里的委屈有了发泄口，我赶紧回答是啊，我还没学过这方面的知识，然后他就说他也是业余的，他是学新闻的，花了半年多边做边学才搞懂，还给我分享了他的博客。（哈哈其实我想要的很多功能他都有，但是我觉得全都问人家好像太打扰别人了，默默羡慕……）\n  其实有时候我也会想，我是不是特别笨，或者说学习能力很弱，我是不是不适合学这个做这个呢，计算机真的适合我吗？我总觉得自己学知识很慢，好像别人理解能力都很强，新的知识很快就能掌握了。这个疑问似乎很早就出现了，我之所以有的成绩出色是因为我花费了更多的精力和时间，而不是因为我学的好，所谓学的好我认为应该是学的快、理解掌握的快。而我不属于那类人，可能我本来就是那种比较笨的。\n  总而言之，目前就先这样吧，后续的摸索中等我搞明白了再慢慢完善。现在才刚刚开始，我还有好长好长的路要走啊……\n","thumbnail":"2020/hello-blog/sky.jpg","color":"#111","plink":"https://vichin0215.github.io/2020/hello-blog/"},{"title":"go语言搭建pipeline","date":"2020-04-02T03:27:33.000Z","date_formatted":{"ll":"2020年4月2日","L":"2020/04/02","MM-DD":"04-02"},"updated":"2020-06-05T08:16:48.060Z","content":"pipeline有个数据源，把这个数据源送到一个节点，这个节点处理完再送到下一个节点，这样一级一级送下去，最后又一个Sink，Sink节点只进不出。\n节点和节点之间怎么通信呢？\n传统语言是通过方法调用实现的。\nGo语言是通过channel通信的\n归并排序数据分为左右两半，分别归并排序，再把两个有序数据合并\n外部排序pipeline首先有个原始数据，然后分块得读取这个原始数据，保证内存能够放得下，每一块各自进行内部排序，排好序后两两进行归并，每个归并节点放的都是排好序的大数据，然后再两两归并，最后写入文件中。\n\n实现基础节点首先我们有一个数据源，它返回的是一个channel\n12345678910func ArraySource(a ...int) &lt;-chan int &#123;\tout := make(chan int)\tgo func() &#123;\t\tfor _, v := range a &#123;\t\t\tout &lt;- v\t\t&#125;\t\tclose(out)\t&#125;()\treturn out&#125;然后对这个数据源进行内部排序\n12345678910111213141516171819func InMenSort(in &lt;-chan int) &lt;-chan int &#123;\tout := make(chan int)\tgo func() &#123;\t\t// Read into memory\t\ta := []int&#123;&#125;\t\tfor v := range in &#123;\t\t\ta = append(a, v)\t\t&#125;\t\t// Sort\t\tsort.Ints(a)\t\t//Output\t\tfor _, v := range a &#123;\t\t\tout &lt;- v\t\t&#125;\t\tclose(out)\t&#125;()\treturn out&#125;主函数直接拼接起来\n123456789101112131415package mainimport (\t\"fmt\"\t\"pipeline/pipeline\")func main() &#123;\tp := pipeline.InMenSort(pipeline.ArraySource(3, 2, 6, 7, 4))\t// 用range发送方一定要close\tfor v := range p &#123;\t\tfmt.Println(v)\t&#125;&#125;这样我们就实现了一个基础的内部排序了！\n归并节点讲两个内部排序归并\n123456789101112131415161718func Merge(in1, in2 &lt;-chan int) &lt;-chan int &#123;    out := make(chan int)    go func() &#123;      v1, ok1 := &lt;-in1      v2, ok2 := &lt;-in2      for ok1 || ok2 &#123;        if !ok2 || (ok1 &amp;&amp; v1 &lt;= v2) &#123;          out &lt;- v1          v1, ok1 = &lt;-in1        &#125; else &#123;          out &lt;- v2          v2, ok2 = &lt;-in2        &#125;      &#125;      close(out)    &#125;()    return out&#125;主函数merge两个内部排序节点\n1234567891011121314package mainimport (\t\"fmt\"\t\"pipeline/pipeline\")func main() &#123;\tp := pipeline.Merge(pipeline.InMenSort(pipeline.ArraySource(3, 2, 6, 7, 4)),pipeline.InMenSort(pipeline.ArraySource(1, 2, 9, 5, 3)))\t// 用range发送方一定要close\tfor v := range p &#123;\t\tfmt.Println(v)\t&#125;&#125;现在我们已经实现了从array读取数据源，然后用两个内部排序节点排序，最后再通过merge将两个节点归并。\n我们的数据源是从array读取，这点不好，让我们来从文件中读取吧！\n文件读写在外部排序中数据源要是一个文件\n读文件，这里统一用大端BigEndian读取数据\n12345678910111213141516171819func ReaderSource(reader io.Reader) &lt;-chan int &#123;\tout := make(chan int)\tgo func() &#123;\t\tbuffer := make([]byte, 8)\t\tfor &#123;\t\t\tn, err := reader.Read(buffer)\t\t\tif n &gt; 0 &#123;\t\t\t\t// 把[]byte转化为int\t\t\t\tv := int(binary.BigEndian.Uint64(buffer))\t\t\t\tout &lt;- v\t\t\t&#125;\t\t\tif err != nil &#123;\t\t\t\tbreak\t\t\t&#125;\t\t&#125;\t\tclose(out)\t&#125;()\treturn out&#125;写文件\n1234567func WriterSink(writer io.Writer, in &lt;-chan int) &#123;\tfor v := range in &#123;\t\tbuffer := make([]byte, 8)\t\tbinary.BigEndian.PutUint64(buffer, uint64(v))\t\twriter.Write(buffer)\t&#125;&#125;当然数据源应该是自动产生的，我们再实现一个随机产生数据源的方法\n123456789func RandomSource(count int) &lt;-chan int &#123;\tout := make(chan int)\tgo func() &#123;\t\tfor i := 0; i &lt; count; i++ &#123;\t\t\tout &lt;- rand.Int()\t\t&#125;\t&#125;()\treturn out&#125;我们的main函数如下\n1234567891011121314151617181920212223242526func main() &#123;\tconst filename = \"large.in\"\tconst n = 100000000\tfile, err := os.Create(filename)\tif err != nil &#123;\t\tpanic(err)\t&#125;\tdefer file.Close()\tp := pipeline.RandomSource(n)\tpipeline.WriterSink(file, p)\tfile, err = os.Open(filename)\tif err != nil &#123;\t\tpanic(err)\t&#125;\tdefer file.Close()\tp = pipeline.ReaderSource(file)\tcount := 0\tfor v := range p &#123;\t\tfmt.Println(v)\t\tcount++\t\tif count &gt;= 100 &#123;\t\t\tbreak\t\t&#125;\t&#125;&#125;这就实现了自动生成随机数，并写入文件\n但是上面这段代码是大数据，一共产生100兆个数，速度很慢，为什么这么慢呢？\n因为Reader和Writer没有buffer\n我们再给Reader和Writer加个buffer\n12345678910111213141516171819202122232425262728293031func main() &#123;    const filename = \"large.in\"    const n = 100000000    file, err := os.Create(filename)    if err != nil &#123;      \tpanic(err)    &#125;    defer file.Close()    p := pipeline.RandomSource(n)    writer := bufio.NewWriter(file)    pipeline.WriterSink(writer, p)    writer.Flush()    file, err = os.Open(filename)    if err != nil &#123;      \tpanic(err)    &#125;    defer file.Close()    reader := bufio.NewReader(file)    p = pipeline.ReaderSource(reader)    count := 0    for v := range p &#123;      fmt.Println(v)      count++      if count &gt;= 100 &#123;          break        &#125;    &#125;&#125;buffer的writer要记得flush，不然得到的数据就不是800兆了。\n现在我们实现了更多的节点，有ReaderSource和WriterSink，我们又用随机数演示测试数据的生成，都用bufio包装了，所以速度很快\n完整外部排序现在我们这个外部排序pipeline还有一些没有完成，一个是读取文件要分块读取，还有两两归并再归并还没有实现\n现在我们来实现这些功能吧！\n首先我们来实现多路的两两归并\n123456789func MergeN(inputs ...&lt;-chan int) &lt;-chan int &#123;    if len(inputs) == 1 &#123;      return inputs[0]    &#125;    m := len(inputs) / 2    // merge inputs[0..m) and inputs[m..end)    return Merge(MergeN(inputs[:m]...), MergeN(inputs[m:]...))&#125;看起来很简单啊，只是用递归去实现了一下\n然后我们reader读文件要分块\n那我们来改造一下ReaderSource\n123456789101112131415161718192021func ReaderSource(reader io.Reader, chunkSize int) &lt;-chan int &#123;\tout := make(chan int)\tgo func() &#123;      buffer := make([]byte, 8)      bytesRead := 0      for &#123;          n, err := reader.Read(buffer)          bytesRead += n          if n &gt; 0 &#123;              // 把[]byte转化为int              v := int(binary.BigEndian.Uint64(buffer))              out &lt;- v          &#125;          if err != nil || (chunkSize != -1 &amp;&amp; bytesRead &gt;= chunkSize) &#123;              break          &#125;      &#125;      close(out)\t&#125;()\treturn out&#125;这里我们设置chunkSize为-1表示全部读，否则就是不能超过chunkSize读取\n很简单吧！现在我们开始实现外部排序吧！\n首先我们来创建一个pipeline\n123456789101112131415161718func createPipeline(filename string, fileSize, chunkCount int) &lt;-chan int &#123;    chunkSize := fileSize / chunkCount    sortResults := []&lt;-chan int&#123;&#125;    for i := 0; i &lt; chunkCount; i++ &#123;        file, err := os.Open(filename)        if err != nil &#123;          \tpanic(err)        &#125;        // file要从这一块开始读，所以file要移动一下        file.Seek(int64(chunkSize * i), 0)        source := pipeline.ReaderSource(bufio.NewReader(file), chunkSize)        sortResults= append(sortResults, pipeline.InMenSort(source))    &#125;    return pipeline.MergeN(sortResults...)&#125;这里我们分块去读，每次读file都移动一下，然后排好序，把结果merge起来。\n接下来我们把排好序的数据写入文件\n123456789101112func writeToFile(p &lt;-chan int, filename string) &#123;    file, err := os.Create(filename)    if err != nil &#123;      \tpanic(err)    &#125;    defer file.Close()    writer := bufio.NewWriter(file)    defer writer.Flush()    pipeline.WriterSink(writer, p)&#125;然后再打印出来\n123456789101112func printFile(filename string) &#123;    file, err := os.Open(filename)    if err != nil &#123;      \tpanic(err)    &#125;    defer file.Close()    p := pipeline.ReaderSource(file, -1)    for v := range p &#123;      \tfmt.Println(v)    &#125;&#125;最后主函数这样写\n12345func main() &#123;    p := createPipeline(\"small.in\", 512, 4)    writeToFile(p, \"small.out\")    printFile(\"small.out\")&#125;但是程序还是很慢，排序需要跑将近30秒，我们看慢在哪里，channel是无缓存的，这样就会阻塞等待，所以我们给channel加个1024的缓存。\n虽然排序是并行的排的，但是merge是O(n)的，每个数都要过一下。所以时间比非并行的要慢。\n我们来看一下输出结果：\n\n很好！\n网络版外部排序InMemSort和WriterSink之间通过网络连接，ReaderSource和Merge之间通过网络连接\n首先我们把服务器搭起来\n1234567891011121314151617181920func NetWorkSink(addr string, in &lt;-chan int) &#123;    listener, err := net.Listen(\"tcp\", addr)    if err != nil &#123;      \tpanic(err)    &#125;    go func() &#123;      defer listener.Close()      conn, err := listener.Accept()      if err != nil &#123;        \tpanic(err)      &#125;      defer conn.Close()      writer := bufio.NewWriter(conn)      defer writer.Flush()      WriterSink(writer, in)    &#125;()&#125;然后封装一下客户端\n12345678910111213141516func NetworkSource(addr string) &lt;-chan int &#123;    out := make(chan int)    go func() &#123;        conn, err := net.Dial(\"tcp\", addr)        if err != nil &#123;          \tpanic(err)        &#125;        r := ReaderSource(bufio.NewReader(conn), -1)        for v := range r &#123;          \tout &lt;- v        &#125;        close(out)    &#125;()    return out&#125;然后我们再把createPipeline封装成network版\n1234567891011121314151617181920212223242526func createNetworkPipeline(filename string, fileSize, chunkCount int) &lt;-chan int &#123;    chunkSize := fileSize / chunkCount    pipeline.Init()    sortAddr := []string&#123;&#125;    for i := 0; i &lt; chunkCount; i++ &#123;        file, err := os.Open(filename)        if err != nil &#123;          \tpanic(err)      &#125;      // file要从这一块开始读，所以file要移动一下      file.Seek(int64(chunkSize * i), 0)      source := pipeline.ReaderSource(bufio.NewReader(file), chunkSize)      addr := \":\" + strconv.Itoa(7000 + i)      pipeline.NetWorkSink(addr, pipeline.InMenSort(source))      sortAddr = append(sortAddr, addr)    &#125;    sortResults := []&lt;-chan int&#123;&#125;    for _, addr := range sortAddr &#123;      \tsortResults = append(sortResults, pipeline.NetworkSource(addr))    &#125;    return pipeline.MergeN(sortResults...)&#125;这样就可以部署到服务器上了\n好了，用go语言搭建并行处理管道已经完成了！\n","plink":"https://vichin0215.github.io/2020/from-wxning/"},{"title":"About Me","date":"1999-11-07T12:46:25.000Z","date_formatted":{"ll":"1999年11月7日","L":"1999/11/07","MM-DD":"11-07"},"updated":"2020-05-29T11:09:41.899Z","content":"hi\n\n","plink":"https://vichin0215.github.io/about/"}]